%{
// Includes the definition of symbolic tokens. The enum definition in this
// header file replaces the `enum Token {...}` you wrote in project 1.
// It also includes the declaration of the global variable `yylval` which will
// be used by code generated by Yacc/Bison.
//
// This header file is generated by Yacc/Bison from parser.y. We suggest that
// you take a look at the content of this header file - it's not long.
#include "y.tab.h"

#include <stdio.h>
#include <stdlib.h>
extern int yylex();

void syntax_error() {
    fprintf(stderr, "Syntax eeeeerrors in %d\n", yylineno);
}

%}

%option yylineno

%%
[ \t\r\n]*                     { }                                                /* whitespace */
"//".*                         { }                                                /* inline comments */
"/*"([^*]|"*"+[^*/])*"*"+"/"   { }                                                /* block comments */

"&&"                   { return TOK_AND; }                                        /* operators */
"!="                   { return TOK_NEQ; }
"||"                   { return TOK_OR; }
"<"                    { return *yytext; }
">"                    { return *yytext; }
"<="                   { return TOK_LEQ; }
">="                   { return TOK_GEQ; }
"=="                   { return TOK_EQLEQL; }
"+"                    { return *yytext; }
"-"                    { return *yytext; }
"*"                    { return *yytext; }
"/"                    { return *yytext; }
"!"                    { return *yytext; }
"++"                   { syntax_error(); }
"--"                   { syntax_error(); }

"public"               { return KW_PUBLIC; }                                      /* keywords */
"private"              { return KW_PRIVATE; }
"static"               { return KW_STATIC; }
"class"                { return KW_CLASS; }
"main"                 { return MAIN; }
"void"                 { return KW_VOID; }
"int"                  { return KW_INT; }
"String"               { return KW_STR; }
"boolean"              { return KW_BOOL; }
"if"                   { return KW_IF; }
"else"                 { return KW_ELSE; }
"while"                { return KW_WHILE; }
"new"                  { return KW_NEW; }
"return"               { return KW_RETURN; }
"System"               { return KW_SYSTEM; }
"out"                  { return KW_OUT; }
"print"                { return KW_PRINT; }
"println"              { return KW_PRINTLN; }
"Integer"              { return CLASS_INTEGER; }
"parseInt"             { return INTEGER_PARSEINT; }
"length"               { return STRING_LENGTH; }
"true"                 { return KW_TRUE; }
"false"                { return KW_FALSE; }

"."                    { return *yytext; }                                        /* other terminals */
";"                    { return *yytext; }
","                    { return *yytext; }
"="                    { return *yytext; }
"("                    { return *yytext; }
")"                    { return *yytext; }
"{"                    { return *yytext; }
"}"                    { return *yytext; }
"["                    { return *yytext; }
"]"                    { return *yytext; }

[0-9]+                 { yylval.integer = atoi(strdup(yytext)); return INT_LIT; } /* int literal */
\"([^\\\"]|\\.)*\"     { yylval.string = strdup(yytext); return STR_LIT; }        /* string literal */
[a-zA-Z][_a-zA-Z0-9]*  { yylval.string = strdup(yytext); return ID; }             /* identifiers */

.                      { syntax_error(); }                                        /* all other characters */

%%

int yywrap(void) {
    return 1;
}
